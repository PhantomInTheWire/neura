# from sqlalchemy import Column, String, DateTime, Text
# from sqlalchemy.ext.declarative import declarative_base
from pydantic import BaseModel, Field, GetJsonSchemaHandler
from pydantic_core import core_schema
from typing import Optional, List, Any
from datetime import datetime
from bson import ObjectId # Import ObjectId

# Pydantic V2 compatible helper class for MongoDB ObjectId
class PyObjectId(ObjectId):
    @classmethod
    def __get_pydantic_core_schema__(
        cls, source_type: Any, handler: Any # handler type hint might need refinement based on pydantic version
    ) -> core_schema.CoreSchema:
        """
        Defines the core schema for ObjectId validation.
        It expects a string or ObjectId, validates it, and returns an ObjectId instance.
        """
        def validate_from_str(v: str) -> ObjectId:
            if not ObjectId.is_valid(v):
                raise ValueError("Invalid ObjectId")
            return ObjectId(v)
    
        # Schema for validating input (either ObjectId instance or a string)
        from_input_schema = core_schema.union_schema(
            [
                # Check if it's already an ObjectId instance
                core_schema.is_instance_schema(ObjectId),
                # If not, try validating from a string
                core_schema.no_info_plain_validator_function(validate_from_str),
            ]
        )

        return core_schema.json_or_python_schema(
            json_schema=from_input_schema,
            python_schema=core_schema.union_schema([
                core_schema.is_instance_schema(ObjectId),
                from_input_schema # Reuse validation logic for Python objects
            ]),
            serialization=core_schema.plain_serializer_function_ser_schema(lambda x: str(x)),
        )

    @classmethod
    def __get_pydantic_json_schema__(
        cls, core_schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler
    ) -> dict[str, Any]:
        """
        Modifies the JSON schema to represent ObjectId as a string.
        """
        # Get the default JSON schema generated by Pydantic
        json_schema = handler(core_schema)
        # Override the type to be 'string' in the JSON schema
        json_schema.update(type='string', format='objectid')
        return json_schema

# --- Workspace Models ---
class WorkspaceBase(BaseModel):
    title: str
    description: Optional[str] = None

class WorkspaceCreate(WorkspaceBase):
    pass

class WorkspaceUpdate(WorkspaceBase):
    pass

class Workspace(WorkspaceBase):
    # Use PyObjectId for the id field, aliased to MongoDB's _id
    id: PyObjectId = Field(default_factory=PyObjectId, alias="_id")
    created_at: datetime = Field(default_factory=datetime.utcnow)

    class Config:
        populate_by_name = True # Pydantic v2 equivalent of allow_population_by_field_name
        arbitrary_types_allowed = True # Still useful for ObjectId if not perfectly handled by schema
        # json_encoders is deprecated in V2; serialization is handled by __get_pydantic_core_schema__

# --- Topics Models (Keep if still needed, or remove if study guide handles hierarchy) ---
class TopicNode(BaseModel):
    id: int # Note: This might change if Topics become Mongo documents with ObjectId
    name: str
    x: float
    y: float
    completionPercentage: float

class TopicEdge(BaseModel):
    sourceTopicId: int # Might change if Topic IDs change
    targetTopicId: int # Might change if Topic IDs change

class TopicCreate(BaseModel):
    name: str
    notebookId: int # Might change to workspaceId (str/ObjectId)
    parentTopicId: int | None = None # Might change if Topic IDs change
    orderPosition: int

# --- Enhanced Study Guide Models (Hierarchical) ---

class ExtractedImageInfo(BaseModel):
    # Represents info about an image extracted from the document
    filename: str # The unique filename saved temporarily (e.g., uuid.png)
    # Optional: Add page number if extractable, useful for frontend display
    page_number: int | None = None
    gridfs_id: Optional[PyObjectId] = None # ID of the image file stored in GridFS

class StudyGuideSubsection(BaseModel):
    # Represents one subsection within a main section
    subsection_title: str # Title generated by Gemini
    explanation: str # Detailed explanation with Markdown + image refs
    # Images associated specifically with this subsection
    associated_image_filenames: List[str] = []

class StudyGuideSection(BaseModel):
    # Represents one main section
    section_title: str # Main title generated by Gemini
    # New fields for the overview:
    section_overview_description: str # Brief description/goal of the section
    subsection_titles: List[str] # List of titles for subsections within this section
    # List of actual subsection content objects
    subsections: List[StudyGuideSubsection]

class StudyGuideResponse(BaseModel):
    # The final response structure for the API endpoint
    original_filename: str
    extracted_images: List[ExtractedImageInfo] # All extracted (potentially pre-filtered) images
    study_guide: List[StudyGuideSection] # List of main sections

    # Add id field if we plan to return the created study guide document from DB
    id: Optional[PyObjectId] = Field(alias="_id", default=None)
    # Add field to store the GridFS ID of the original uploaded PDF
    original_pdf_gridfs_id: Optional[PyObjectId] = None
    # Add field to link this study guide to a workspace
    workspace_id: PyObjectId # This should be required

    class Config:
        populate_by_name = True
        arbitrary_types_allowed = True
        # json_encoders is deprecated in V2
